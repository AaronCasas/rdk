// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"

	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RobotServiceClient is the client API for RobotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RobotServiceClient interface {
	// Status returns the robot's underlying status.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// StatusStream periodically sends the robot's status.
	StatusStream(ctx context.Context, in *StatusStreamRequest, opts ...grpc.CallOption) (RobotService_StatusStreamClient, error)
	// Config gets the config from a server
	// It is only partial a config, including the pieces relevant to remote robots,
	// And not the pieces relevant to local configuration (pins, security keys, etc...)
	Config(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ConfigResponse, error)
	// DoAction runs an action on the underlying robot.
	DoAction(ctx context.Context, in *DoActionRequest, opts ...grpc.CallOption) (*DoActionResponse, error)
	// ArmCurrentPosition gets the current position of an arm of the underlying robot.
	ArmCurrentPosition(ctx context.Context, in *ArmCurrentPositionRequest, opts ...grpc.CallOption) (*ArmCurrentPositionResponse, error)
	// ArmMoveToPosition moves an arm of the underlying robot to the requested position.
	ArmMoveToPosition(ctx context.Context, in *ArmMoveToPositionRequest, opts ...grpc.CallOption) (*ArmMoveToPositionResponse, error)
	// ArmCurrentJointPositions gets the current joint position of an arm of the underlying robot.
	ArmCurrentJointPositions(ctx context.Context, in *ArmCurrentJointPositionsRequest, opts ...grpc.CallOption) (*ArmCurrentJointPositionsResponse, error)
	// ArmMoveToJointPositions moves an arm of the underlying robot to the requested joint positions.
	ArmMoveToJointPositions(ctx context.Context, in *ArmMoveToJointPositionsRequest, opts ...grpc.CallOption) (*ArmMoveToJointPositionsResponse, error)
	// ArmJointMoveDelta moves a specific joint of an arm of the underlying robot by the given amount.
	ArmJointMoveDelta(ctx context.Context, in *ArmJointMoveDeltaRequest, opts ...grpc.CallOption) (*ArmJointMoveDeltaResponse, error)
	// BaseMoveStraight moves a base of the underlying robot straight.
	BaseMoveStraight(ctx context.Context, in *BaseMoveStraightRequest, opts ...grpc.CallOption) (*BaseMoveStraightResponse, error)
	// BaseSpin spins a base of the underlying robot.
	BaseSpin(ctx context.Context, in *BaseSpinRequest, opts ...grpc.CallOption) (*BaseSpinResponse, error)
	// BaseSpin stops a base of the underlying robot.
	BaseStop(ctx context.Context, in *BaseStopRequest, opts ...grpc.CallOption) (*BaseStopResponse, error)
	// BaseWidthMillis returns the width of a base of the underlying robot.
	BaseWidthMillis(ctx context.Context, in *BaseWidthMillisRequest, opts ...grpc.CallOption) (*BaseWidthMillisResponse, error)
	// GripperOpen opens a gripper of the underlying robot.
	GripperOpen(ctx context.Context, in *GripperOpenRequest, opts ...grpc.CallOption) (*GripperOpenResponse, error)
	// GripperGrab requests a gripper of the underlying robot to grab.
	GripperGrab(ctx context.Context, in *GripperGrabRequest, opts ...grpc.CallOption) (*GripperGrabResponse, error)
	// CameraFrame returns a frame from a camera of the underlying robot. A specific MIME type
	// can be requested but may not necessarily be the same one returned.
	CameraFrame(ctx context.Context, in *CameraFrameRequest, opts ...grpc.CallOption) (*CameraFrameResponse, error)
	// CameraFrame renders a frame from a camera of the underlying robot to an HTTP response. A specific MIME type
	// can be requested but may not necessarily be the same one returned.
	CameraRenderFrame(ctx context.Context, in *CameraRenderFrameRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error)
	// PointCloud returns a point cloud from a camera of the underlying robot. A specific MIME type
	// can be requested but may not necessarily be the same one returned.
	PointCloud(ctx context.Context, in *PointCloudRequest, opts ...grpc.CallOption) (*PointCloudResponse, error)
	// ObjectPointClouds returns all the found objects in a pointcloud from a camera of the underlying robot,
	// as well as the 3-vector center of each of the found objects.
	// A specific MIME type can be requested but may not necessarily be the same one returned.
	ObjectPointClouds(ctx context.Context, in *ObjectPointCloudsRequest, opts ...grpc.CallOption) (*ObjectPointCloudsResponse, error)
	// LidarInfo returns the info of a lidar of the underlying robot.
	LidarInfo(ctx context.Context, in *LidarInfoRequest, opts ...grpc.CallOption) (*LidarInfoResponse, error)
	// LidarStart starts a lidar of the underlying robot.
	LidarStart(ctx context.Context, in *LidarStartRequest, opts ...grpc.CallOption) (*LidarStartResponse, error)
	// LidarStop stops a lidar of the underlying robot.
	LidarStop(ctx context.Context, in *LidarStopRequest, opts ...grpc.CallOption) (*LidarStopResponse, error)
	// LidarScan returns a scan from a lidar of the underlying robot.
	LidarScan(ctx context.Context, in *LidarScanRequest, opts ...grpc.CallOption) (*LidarScanResponse, error)
	// LidarRange returns the range of a lidar of the underlying robot.
	LidarRange(ctx context.Context, in *LidarRangeRequest, opts ...grpc.CallOption) (*LidarRangeResponse, error)
	// LidarBounds returns the scan bounds of a lidar of the underlying robot.
	LidarBounds(ctx context.Context, in *LidarBoundsRequest, opts ...grpc.CallOption) (*LidarBoundsResponse, error)
	// LidarAngularResolution returns the scan angular resolution of a lidar of the underlying robot.
	LidarAngularResolution(ctx context.Context, in *LidarAngularResolutionRequest, opts ...grpc.CallOption) (*LidarAngularResolutionResponse, error)
	// BoardStatus returns the status of a board of the underlying robot.
	BoardStatus(ctx context.Context, in *BoardStatusRequest, opts ...grpc.CallOption) (*BoardStatusResponse, error)
	// BoardGPIOSet sets the given pin of a board of the underlying robot to either low or high.
	BoardGPIOSet(ctx context.Context, in *BoardGPIOSetRequest, opts ...grpc.CallOption) (*BoardGPIOSetResponse, error)
	// BoardGPIOGet gets the high/low state of the given pin of a board of the underlying robot.
	BoardGPIOGet(ctx context.Context, in *BoardGPIOGetRequest, opts ...grpc.CallOption) (*BoardGPIOGetResponse, error)
	// BoardPWMSet sets the given pin of a board of the underlying robot to the given duty cycle.
	BoardPWMSet(ctx context.Context, in *BoardPWMSetRequest, opts ...grpc.CallOption) (*BoardPWMSetResponse, error)
	// BoardPWMSetFrequency sets the given pin of a board of the underlying robot to the given PWM frequency. 0 will use the board's default PWM frequency.
	BoardPWMSetFrequency(ctx context.Context, in *BoardPWMSetFrequencyRequest, opts ...grpc.CallOption) (*BoardPWMSetFrequencyResponse, error)
	// BoardMotorPower requests the motor of a board of the underlying robot to set its power.
	BoardMotorPower(ctx context.Context, in *BoardMotorPowerRequest, opts ...grpc.CallOption) (*BoardMotorPowerResponse, error)
	// BoardMotorGo requests the motor of a board of the underlying robot to go.
	BoardMotorGo(ctx context.Context, in *BoardMotorGoRequest, opts ...grpc.CallOption) (*BoardMotorGoResponse, error)
	// BoardMotorGoFor requests the motor of a board of the underlying robot to go for a certain amount based off
	// the request.
	BoardMotorGoFor(ctx context.Context, in *BoardMotorGoForRequest, opts ...grpc.CallOption) (*BoardMotorGoForResponse, error)
	// BoardMotorGoTo requests the motor of a board of the underlying robot to move to a specific position.
	BoardMotorGoTo(ctx context.Context, in *BoardMotorGoToRequest, opts ...grpc.CallOption) (*BoardMotorGoToResponse, error)
	// BoardMotorGoTillStop requests the motor of a board of the underlying robot to move until stopped (either physically or by limit switch.)
	BoardMotorGoTillStop(ctx context.Context, in *BoardMotorGoTillStopRequest, opts ...grpc.CallOption) (*BoardMotorGoTillStopResponse, error)
	// BoardMotorZero requests the motor of a board of the underlying robot to set a new zero/home position.
	BoardMotorZero(ctx context.Context, in *BoardMotorZeroRequest, opts ...grpc.CallOption) (*BoardMotorZeroResponse, error)
	// BoardMotorPosition reports the position of the motor of a board of the underlying robot based on its encoder. If it's not supported, the returned
	// data is undefined. The unit returned is the number of revolutions which is intended to be fed
	// back into calls of BoardMotorGoFor.
	BoardMotorPosition(ctx context.Context, in *BoardMotorPositionRequest, opts ...grpc.CallOption) (*BoardMotorPositionResponse, error)
	// BoardMotorPositionSupported returns whether or not the motor of a board of the underlying robot supports reporting of its position which
	// is reliant on having an encoder.
	BoardMotorPositionSupported(ctx context.Context, in *BoardMotorPositionSupportedRequest, opts ...grpc.CallOption) (*BoardMotorPositionSupportedResponse, error)
	// BoardMotorOff turns the motor of a board of the underlying robot off.
	BoardMotorOff(ctx context.Context, in *BoardMotorOffRequest, opts ...grpc.CallOption) (*BoardMotorOffResponse, error)
	BoardMotorIsOn(ctx context.Context, in *BoardMotorIsOnRequest, opts ...grpc.CallOption) (*BoardMotorIsOnResponse, error)
	// BoardServoMove requests the servo of a board of the underlying robot to move.
	BoardServoMove(ctx context.Context, in *BoardServoMoveRequest, opts ...grpc.CallOption) (*BoardServoMoveResponse, error)
	// BoardServoCurrent returns the current set angle (degrees) of the servo a board of the underlying robot.
	BoardServoCurrent(ctx context.Context, in *BoardServoCurrentRequest, opts ...grpc.CallOption) (*BoardServoCurrentResponse, error)
	// BoardAnalogReaderRead reads off the current value of an analog reader of a board of the underlying robot.
	BoardAnalogReaderRead(ctx context.Context, in *BoardAnalogReaderReadRequest, opts ...grpc.CallOption) (*BoardAnalogReaderReadResponse, error)
	// BoardDigitalInterruptConfig returns the config the interrupt was created with.
	BoardDigitalInterruptConfig(ctx context.Context, in *BoardDigitalInterruptConfigRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptConfigResponse, error)
	// BoardDigitalInterruptValue returns the current value of the interrupt which is based on the type of interrupt.
	BoardDigitalInterruptValue(ctx context.Context, in *BoardDigitalInterruptValueRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptValueResponse, error)
	// BoardDigitalInterruptTick is to be called either manually if the interrupt is a proxy to some real hardware interrupt or for tests.
	BoardDigitalInterruptTick(ctx context.Context, in *BoardDigitalInterruptTickRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptTickResponse, error)
	// SensorReadings returns the readings of a sensor of the underlying robot.
	SensorReadings(ctx context.Context, in *SensorReadingsRequest, opts ...grpc.CallOption) (*SensorReadingsResponse, error)
	// CompassHeading returns the heading of a compass of the underlying robot.
	CompassHeading(ctx context.Context, in *CompassHeadingRequest, opts ...grpc.CallOption) (*CompassHeadingResponse, error)
	// CompassStartCalibration requests the compass of the underlying robot to start calibration.
	CompassStartCalibration(ctx context.Context, in *CompassStartCalibrationRequest, opts ...grpc.CallOption) (*CompassStartCalibrationResponse, error)
	// CompassStopCalibration requests the compass of the underlying robot to stop calibration.
	CompassStopCalibration(ctx context.Context, in *CompassStopCalibrationRequest, opts ...grpc.CallOption) (*CompassStopCalibrationResponse, error)
	// CompassMark requests the relative compass of the underlying robot to mark its position.
	CompassMark(ctx context.Context, in *CompassMarkRequest, opts ...grpc.CallOption) (*CompassMarkResponse, error)
}

type robotServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRobotServiceClient(cc grpc.ClientConnInterface) RobotServiceClient {
	return &robotServiceClient{cc}
}

func (c *robotServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) StatusStream(ctx context.Context, in *StatusStreamRequest, opts ...grpc.CallOption) (RobotService_StatusStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &RobotService_ServiceDesc.Streams[0], "/proto.api.v1.RobotService/StatusStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &robotServiceStatusStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RobotService_StatusStreamClient interface {
	Recv() (*StatusStreamResponse, error)
	grpc.ClientStream
}

type robotServiceStatusStreamClient struct {
	grpc.ClientStream
}

func (x *robotServiceStatusStreamClient) Recv() (*StatusStreamResponse, error) {
	m := new(StatusStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *robotServiceClient) Config(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ConfigResponse, error) {
	out := new(ConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/Config", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) DoAction(ctx context.Context, in *DoActionRequest, opts ...grpc.CallOption) (*DoActionResponse, error) {
	out := new(DoActionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/DoAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ArmCurrentPosition(ctx context.Context, in *ArmCurrentPositionRequest, opts ...grpc.CallOption) (*ArmCurrentPositionResponse, error) {
	out := new(ArmCurrentPositionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ArmCurrentPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ArmMoveToPosition(ctx context.Context, in *ArmMoveToPositionRequest, opts ...grpc.CallOption) (*ArmMoveToPositionResponse, error) {
	out := new(ArmMoveToPositionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ArmMoveToPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ArmCurrentJointPositions(ctx context.Context, in *ArmCurrentJointPositionsRequest, opts ...grpc.CallOption) (*ArmCurrentJointPositionsResponse, error) {
	out := new(ArmCurrentJointPositionsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ArmCurrentJointPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ArmMoveToJointPositions(ctx context.Context, in *ArmMoveToJointPositionsRequest, opts ...grpc.CallOption) (*ArmMoveToJointPositionsResponse, error) {
	out := new(ArmMoveToJointPositionsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ArmMoveToJointPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ArmJointMoveDelta(ctx context.Context, in *ArmJointMoveDeltaRequest, opts ...grpc.CallOption) (*ArmJointMoveDeltaResponse, error) {
	out := new(ArmJointMoveDeltaResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ArmJointMoveDelta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseMoveStraight(ctx context.Context, in *BaseMoveStraightRequest, opts ...grpc.CallOption) (*BaseMoveStraightResponse, error) {
	out := new(BaseMoveStraightResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseMoveStraight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseSpin(ctx context.Context, in *BaseSpinRequest, opts ...grpc.CallOption) (*BaseSpinResponse, error) {
	out := new(BaseSpinResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseSpin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseStop(ctx context.Context, in *BaseStopRequest, opts ...grpc.CallOption) (*BaseStopResponse, error) {
	out := new(BaseStopResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseWidthMillis(ctx context.Context, in *BaseWidthMillisRequest, opts ...grpc.CallOption) (*BaseWidthMillisResponse, error) {
	out := new(BaseWidthMillisResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseWidthMillis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) GripperOpen(ctx context.Context, in *GripperOpenRequest, opts ...grpc.CallOption) (*GripperOpenResponse, error) {
	out := new(GripperOpenResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/GripperOpen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) GripperGrab(ctx context.Context, in *GripperGrabRequest, opts ...grpc.CallOption) (*GripperGrabResponse, error) {
	out := new(GripperGrabResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/GripperGrab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CameraFrame(ctx context.Context, in *CameraFrameRequest, opts ...grpc.CallOption) (*CameraFrameResponse, error) {
	out := new(CameraFrameResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CameraFrame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CameraRenderFrame(ctx context.Context, in *CameraRenderFrameRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error) {
	out := new(httpbody.HttpBody)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CameraRenderFrame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) PointCloud(ctx context.Context, in *PointCloudRequest, opts ...grpc.CallOption) (*PointCloudResponse, error) {
	out := new(PointCloudResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/PointCloud", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ObjectPointClouds(ctx context.Context, in *ObjectPointCloudsRequest, opts ...grpc.CallOption) (*ObjectPointCloudsResponse, error) {
	out := new(ObjectPointCloudsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ObjectPointClouds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarInfo(ctx context.Context, in *LidarInfoRequest, opts ...grpc.CallOption) (*LidarInfoResponse, error) {
	out := new(LidarInfoResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarStart(ctx context.Context, in *LidarStartRequest, opts ...grpc.CallOption) (*LidarStartResponse, error) {
	out := new(LidarStartResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarStop(ctx context.Context, in *LidarStopRequest, opts ...grpc.CallOption) (*LidarStopResponse, error) {
	out := new(LidarStopResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarScan(ctx context.Context, in *LidarScanRequest, opts ...grpc.CallOption) (*LidarScanResponse, error) {
	out := new(LidarScanResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarScan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarRange(ctx context.Context, in *LidarRangeRequest, opts ...grpc.CallOption) (*LidarRangeResponse, error) {
	out := new(LidarRangeResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarBounds(ctx context.Context, in *LidarBoundsRequest, opts ...grpc.CallOption) (*LidarBoundsResponse, error) {
	out := new(LidarBoundsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarBounds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarAngularResolution(ctx context.Context, in *LidarAngularResolutionRequest, opts ...grpc.CallOption) (*LidarAngularResolutionResponse, error) {
	out := new(LidarAngularResolutionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarAngularResolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardStatus(ctx context.Context, in *BoardStatusRequest, opts ...grpc.CallOption) (*BoardStatusResponse, error) {
	out := new(BoardStatusResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardGPIOSet(ctx context.Context, in *BoardGPIOSetRequest, opts ...grpc.CallOption) (*BoardGPIOSetResponse, error) {
	out := new(BoardGPIOSetResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardGPIOSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardGPIOGet(ctx context.Context, in *BoardGPIOGetRequest, opts ...grpc.CallOption) (*BoardGPIOGetResponse, error) {
	out := new(BoardGPIOGetResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardGPIOGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardPWMSet(ctx context.Context, in *BoardPWMSetRequest, opts ...grpc.CallOption) (*BoardPWMSetResponse, error) {
	out := new(BoardPWMSetResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardPWMSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardPWMSetFrequency(ctx context.Context, in *BoardPWMSetFrequencyRequest, opts ...grpc.CallOption) (*BoardPWMSetFrequencyResponse, error) {
	out := new(BoardPWMSetFrequencyResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardPWMSetFrequency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorPower(ctx context.Context, in *BoardMotorPowerRequest, opts ...grpc.CallOption) (*BoardMotorPowerResponse, error) {
	out := new(BoardMotorPowerResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorPower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorGo(ctx context.Context, in *BoardMotorGoRequest, opts ...grpc.CallOption) (*BoardMotorGoResponse, error) {
	out := new(BoardMotorGoResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorGo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorGoFor(ctx context.Context, in *BoardMotorGoForRequest, opts ...grpc.CallOption) (*BoardMotorGoForResponse, error) {
	out := new(BoardMotorGoForResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorGoFor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorGoTo(ctx context.Context, in *BoardMotorGoToRequest, opts ...grpc.CallOption) (*BoardMotorGoToResponse, error) {
	out := new(BoardMotorGoToResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorGoTo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorGoTillStop(ctx context.Context, in *BoardMotorGoTillStopRequest, opts ...grpc.CallOption) (*BoardMotorGoTillStopResponse, error) {
	out := new(BoardMotorGoTillStopResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorGoTillStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorZero(ctx context.Context, in *BoardMotorZeroRequest, opts ...grpc.CallOption) (*BoardMotorZeroResponse, error) {
	out := new(BoardMotorZeroResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorZero", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorPosition(ctx context.Context, in *BoardMotorPositionRequest, opts ...grpc.CallOption) (*BoardMotorPositionResponse, error) {
	out := new(BoardMotorPositionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorPositionSupported(ctx context.Context, in *BoardMotorPositionSupportedRequest, opts ...grpc.CallOption) (*BoardMotorPositionSupportedResponse, error) {
	out := new(BoardMotorPositionSupportedResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorPositionSupported", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorOff(ctx context.Context, in *BoardMotorOffRequest, opts ...grpc.CallOption) (*BoardMotorOffResponse, error) {
	out := new(BoardMotorOffResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorOff", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardMotorIsOn(ctx context.Context, in *BoardMotorIsOnRequest, opts ...grpc.CallOption) (*BoardMotorIsOnResponse, error) {
	out := new(BoardMotorIsOnResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardMotorIsOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardServoMove(ctx context.Context, in *BoardServoMoveRequest, opts ...grpc.CallOption) (*BoardServoMoveResponse, error) {
	out := new(BoardServoMoveResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardServoMove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardServoCurrent(ctx context.Context, in *BoardServoCurrentRequest, opts ...grpc.CallOption) (*BoardServoCurrentResponse, error) {
	out := new(BoardServoCurrentResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardServoCurrent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardAnalogReaderRead(ctx context.Context, in *BoardAnalogReaderReadRequest, opts ...grpc.CallOption) (*BoardAnalogReaderReadResponse, error) {
	out := new(BoardAnalogReaderReadResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardAnalogReaderRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardDigitalInterruptConfig(ctx context.Context, in *BoardDigitalInterruptConfigRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptConfigResponse, error) {
	out := new(BoardDigitalInterruptConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardDigitalInterruptConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardDigitalInterruptValue(ctx context.Context, in *BoardDigitalInterruptValueRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptValueResponse, error) {
	out := new(BoardDigitalInterruptValueResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardDigitalInterruptValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardDigitalInterruptTick(ctx context.Context, in *BoardDigitalInterruptTickRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptTickResponse, error) {
	out := new(BoardDigitalInterruptTickResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardDigitalInterruptTick", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) SensorReadings(ctx context.Context, in *SensorReadingsRequest, opts ...grpc.CallOption) (*SensorReadingsResponse, error) {
	out := new(SensorReadingsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/SensorReadings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassHeading(ctx context.Context, in *CompassHeadingRequest, opts ...grpc.CallOption) (*CompassHeadingResponse, error) {
	out := new(CompassHeadingResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassHeading", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassStartCalibration(ctx context.Context, in *CompassStartCalibrationRequest, opts ...grpc.CallOption) (*CompassStartCalibrationResponse, error) {
	out := new(CompassStartCalibrationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassStartCalibration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassStopCalibration(ctx context.Context, in *CompassStopCalibrationRequest, opts ...grpc.CallOption) (*CompassStopCalibrationResponse, error) {
	out := new(CompassStopCalibrationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassStopCalibration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassMark(ctx context.Context, in *CompassMarkRequest, opts ...grpc.CallOption) (*CompassMarkResponse, error) {
	out := new(CompassMarkResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassMark", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RobotServiceServer is the server API for RobotService service.
// All implementations must embed UnimplementedRobotServiceServer
// for forward compatibility
type RobotServiceServer interface {
	// Status returns the robot's underlying status.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	// StatusStream periodically sends the robot's status.
	StatusStream(*StatusStreamRequest, RobotService_StatusStreamServer) error
	// Config gets the config from a server
	// It is only partial a config, including the pieces relevant to remote robots,
	// And not the pieces relevant to local configuration (pins, security keys, etc...)
	Config(context.Context, *ConfigRequest) (*ConfigResponse, error)
	// DoAction runs an action on the underlying robot.
	DoAction(context.Context, *DoActionRequest) (*DoActionResponse, error)
	// ArmCurrentPosition gets the current position of an arm of the underlying robot.
	ArmCurrentPosition(context.Context, *ArmCurrentPositionRequest) (*ArmCurrentPositionResponse, error)
	// ArmMoveToPosition moves an arm of the underlying robot to the requested position.
	ArmMoveToPosition(context.Context, *ArmMoveToPositionRequest) (*ArmMoveToPositionResponse, error)
	// ArmCurrentJointPositions gets the current joint position of an arm of the underlying robot.
	ArmCurrentJointPositions(context.Context, *ArmCurrentJointPositionsRequest) (*ArmCurrentJointPositionsResponse, error)
	// ArmMoveToJointPositions moves an arm of the underlying robot to the requested joint positions.
	ArmMoveToJointPositions(context.Context, *ArmMoveToJointPositionsRequest) (*ArmMoveToJointPositionsResponse, error)
	// ArmJointMoveDelta moves a specific joint of an arm of the underlying robot by the given amount.
	ArmJointMoveDelta(context.Context, *ArmJointMoveDeltaRequest) (*ArmJointMoveDeltaResponse, error)
	// BaseMoveStraight moves a base of the underlying robot straight.
	BaseMoveStraight(context.Context, *BaseMoveStraightRequest) (*BaseMoveStraightResponse, error)
	// BaseSpin spins a base of the underlying robot.
	BaseSpin(context.Context, *BaseSpinRequest) (*BaseSpinResponse, error)
	// BaseSpin stops a base of the underlying robot.
	BaseStop(context.Context, *BaseStopRequest) (*BaseStopResponse, error)
	// BaseWidthMillis returns the width of a base of the underlying robot.
	BaseWidthMillis(context.Context, *BaseWidthMillisRequest) (*BaseWidthMillisResponse, error)
	// GripperOpen opens a gripper of the underlying robot.
	GripperOpen(context.Context, *GripperOpenRequest) (*GripperOpenResponse, error)
	// GripperGrab requests a gripper of the underlying robot to grab.
	GripperGrab(context.Context, *GripperGrabRequest) (*GripperGrabResponse, error)
	// CameraFrame returns a frame from a camera of the underlying robot. A specific MIME type
	// can be requested but may not necessarily be the same one returned.
	CameraFrame(context.Context, *CameraFrameRequest) (*CameraFrameResponse, error)
	// CameraFrame renders a frame from a camera of the underlying robot to an HTTP response. A specific MIME type
	// can be requested but may not necessarily be the same one returned.
	CameraRenderFrame(context.Context, *CameraRenderFrameRequest) (*httpbody.HttpBody, error)
	// PointCloud returns a point cloud from a camera of the underlying robot. A specific MIME type
	// can be requested but may not necessarily be the same one returned.
	PointCloud(context.Context, *PointCloudRequest) (*PointCloudResponse, error)
	// ObjectPointClouds returns all the found objects in a pointcloud from a camera of the underlying robot,
	// as well as the 3-vector center of each of the found objects.
	// A specific MIME type can be requested but may not necessarily be the same one returned.
	ObjectPointClouds(context.Context, *ObjectPointCloudsRequest) (*ObjectPointCloudsResponse, error)
	// LidarInfo returns the info of a lidar of the underlying robot.
	LidarInfo(context.Context, *LidarInfoRequest) (*LidarInfoResponse, error)
	// LidarStart starts a lidar of the underlying robot.
	LidarStart(context.Context, *LidarStartRequest) (*LidarStartResponse, error)
	// LidarStop stops a lidar of the underlying robot.
	LidarStop(context.Context, *LidarStopRequest) (*LidarStopResponse, error)
	// LidarScan returns a scan from a lidar of the underlying robot.
	LidarScan(context.Context, *LidarScanRequest) (*LidarScanResponse, error)
	// LidarRange returns the range of a lidar of the underlying robot.
	LidarRange(context.Context, *LidarRangeRequest) (*LidarRangeResponse, error)
	// LidarBounds returns the scan bounds of a lidar of the underlying robot.
	LidarBounds(context.Context, *LidarBoundsRequest) (*LidarBoundsResponse, error)
	// LidarAngularResolution returns the scan angular resolution of a lidar of the underlying robot.
	LidarAngularResolution(context.Context, *LidarAngularResolutionRequest) (*LidarAngularResolutionResponse, error)
	// BoardStatus returns the status of a board of the underlying robot.
	BoardStatus(context.Context, *BoardStatusRequest) (*BoardStatusResponse, error)
	// BoardGPIOSet sets the given pin of a board of the underlying robot to either low or high.
	BoardGPIOSet(context.Context, *BoardGPIOSetRequest) (*BoardGPIOSetResponse, error)
	// BoardGPIOGet gets the high/low state of the given pin of a board of the underlying robot.
	BoardGPIOGet(context.Context, *BoardGPIOGetRequest) (*BoardGPIOGetResponse, error)
	// BoardPWMSet sets the given pin of a board of the underlying robot to the given duty cycle.
	BoardPWMSet(context.Context, *BoardPWMSetRequest) (*BoardPWMSetResponse, error)
	// BoardPWMSetFrequency sets the given pin of a board of the underlying robot to the given PWM frequency. 0 will use the board's default PWM frequency.
	BoardPWMSetFrequency(context.Context, *BoardPWMSetFrequencyRequest) (*BoardPWMSetFrequencyResponse, error)
	// BoardMotorPower requests the motor of a board of the underlying robot to set its power.
	BoardMotorPower(context.Context, *BoardMotorPowerRequest) (*BoardMotorPowerResponse, error)
	// BoardMotorGo requests the motor of a board of the underlying robot to go.
	BoardMotorGo(context.Context, *BoardMotorGoRequest) (*BoardMotorGoResponse, error)
	// BoardMotorGoFor requests the motor of a board of the underlying robot to go for a certain amount based off
	// the request.
	BoardMotorGoFor(context.Context, *BoardMotorGoForRequest) (*BoardMotorGoForResponse, error)
	// BoardMotorGoTo requests the motor of a board of the underlying robot to move to a specific position.
	BoardMotorGoTo(context.Context, *BoardMotorGoToRequest) (*BoardMotorGoToResponse, error)
	// BoardMotorGoTillStop requests the motor of a board of the underlying robot to move until stopped (either physically or by limit switch.)
	BoardMotorGoTillStop(context.Context, *BoardMotorGoTillStopRequest) (*BoardMotorGoTillStopResponse, error)
	// BoardMotorZero requests the motor of a board of the underlying robot to set a new zero/home position.
	BoardMotorZero(context.Context, *BoardMotorZeroRequest) (*BoardMotorZeroResponse, error)
	// BoardMotorPosition reports the position of the motor of a board of the underlying robot based on its encoder. If it's not supported, the returned
	// data is undefined. The unit returned is the number of revolutions which is intended to be fed
	// back into calls of BoardMotorGoFor.
	BoardMotorPosition(context.Context, *BoardMotorPositionRequest) (*BoardMotorPositionResponse, error)
	// BoardMotorPositionSupported returns whether or not the motor of a board of the underlying robot supports reporting of its position which
	// is reliant on having an encoder.
	BoardMotorPositionSupported(context.Context, *BoardMotorPositionSupportedRequest) (*BoardMotorPositionSupportedResponse, error)
	// BoardMotorOff turns the motor of a board of the underlying robot off.
	BoardMotorOff(context.Context, *BoardMotorOffRequest) (*BoardMotorOffResponse, error)
	BoardMotorIsOn(context.Context, *BoardMotorIsOnRequest) (*BoardMotorIsOnResponse, error)
	// BoardServoMove requests the servo of a board of the underlying robot to move.
	BoardServoMove(context.Context, *BoardServoMoveRequest) (*BoardServoMoveResponse, error)
	// BoardServoCurrent returns the current set angle (degrees) of the servo a board of the underlying robot.
	BoardServoCurrent(context.Context, *BoardServoCurrentRequest) (*BoardServoCurrentResponse, error)
	// BoardAnalogReaderRead reads off the current value of an analog reader of a board of the underlying robot.
	BoardAnalogReaderRead(context.Context, *BoardAnalogReaderReadRequest) (*BoardAnalogReaderReadResponse, error)
	// BoardDigitalInterruptConfig returns the config the interrupt was created with.
	BoardDigitalInterruptConfig(context.Context, *BoardDigitalInterruptConfigRequest) (*BoardDigitalInterruptConfigResponse, error)
	// BoardDigitalInterruptValue returns the current value of the interrupt which is based on the type of interrupt.
	BoardDigitalInterruptValue(context.Context, *BoardDigitalInterruptValueRequest) (*BoardDigitalInterruptValueResponse, error)
	// BoardDigitalInterruptTick is to be called either manually if the interrupt is a proxy to some real hardware interrupt or for tests.
	BoardDigitalInterruptTick(context.Context, *BoardDigitalInterruptTickRequest) (*BoardDigitalInterruptTickResponse, error)
	// SensorReadings returns the readings of a sensor of the underlying robot.
	SensorReadings(context.Context, *SensorReadingsRequest) (*SensorReadingsResponse, error)
	// CompassHeading returns the heading of a compass of the underlying robot.
	CompassHeading(context.Context, *CompassHeadingRequest) (*CompassHeadingResponse, error)
	// CompassStartCalibration requests the compass of the underlying robot to start calibration.
	CompassStartCalibration(context.Context, *CompassStartCalibrationRequest) (*CompassStartCalibrationResponse, error)
	// CompassStopCalibration requests the compass of the underlying robot to stop calibration.
	CompassStopCalibration(context.Context, *CompassStopCalibrationRequest) (*CompassStopCalibrationResponse, error)
	// CompassMark requests the relative compass of the underlying robot to mark its position.
	CompassMark(context.Context, *CompassMarkRequest) (*CompassMarkResponse, error)
	mustEmbedUnimplementedRobotServiceServer()
}

// UnimplementedRobotServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRobotServiceServer struct {
}

func (UnimplementedRobotServiceServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedRobotServiceServer) StatusStream(*StatusStreamRequest, RobotService_StatusStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method StatusStream not implemented")
}
func (UnimplementedRobotServiceServer) Config(context.Context, *ConfigRequest) (*ConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedRobotServiceServer) DoAction(context.Context, *DoActionRequest) (*DoActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoAction not implemented")
}
func (UnimplementedRobotServiceServer) ArmCurrentPosition(context.Context, *ArmCurrentPositionRequest) (*ArmCurrentPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArmCurrentPosition not implemented")
}
func (UnimplementedRobotServiceServer) ArmMoveToPosition(context.Context, *ArmMoveToPositionRequest) (*ArmMoveToPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArmMoveToPosition not implemented")
}
func (UnimplementedRobotServiceServer) ArmCurrentJointPositions(context.Context, *ArmCurrentJointPositionsRequest) (*ArmCurrentJointPositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArmCurrentJointPositions not implemented")
}
func (UnimplementedRobotServiceServer) ArmMoveToJointPositions(context.Context, *ArmMoveToJointPositionsRequest) (*ArmMoveToJointPositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArmMoveToJointPositions not implemented")
}
func (UnimplementedRobotServiceServer) ArmJointMoveDelta(context.Context, *ArmJointMoveDeltaRequest) (*ArmJointMoveDeltaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArmJointMoveDelta not implemented")
}
func (UnimplementedRobotServiceServer) BaseMoveStraight(context.Context, *BaseMoveStraightRequest) (*BaseMoveStraightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseMoveStraight not implemented")
}
func (UnimplementedRobotServiceServer) BaseSpin(context.Context, *BaseSpinRequest) (*BaseSpinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseSpin not implemented")
}
func (UnimplementedRobotServiceServer) BaseStop(context.Context, *BaseStopRequest) (*BaseStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseStop not implemented")
}
func (UnimplementedRobotServiceServer) BaseWidthMillis(context.Context, *BaseWidthMillisRequest) (*BaseWidthMillisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseWidthMillis not implemented")
}
func (UnimplementedRobotServiceServer) GripperOpen(context.Context, *GripperOpenRequest) (*GripperOpenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GripperOpen not implemented")
}
func (UnimplementedRobotServiceServer) GripperGrab(context.Context, *GripperGrabRequest) (*GripperGrabResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GripperGrab not implemented")
}
func (UnimplementedRobotServiceServer) CameraFrame(context.Context, *CameraFrameRequest) (*CameraFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CameraFrame not implemented")
}
func (UnimplementedRobotServiceServer) CameraRenderFrame(context.Context, *CameraRenderFrameRequest) (*httpbody.HttpBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CameraRenderFrame not implemented")
}
func (UnimplementedRobotServiceServer) PointCloud(context.Context, *PointCloudRequest) (*PointCloudResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PointCloud not implemented")
}
func (UnimplementedRobotServiceServer) ObjectPointClouds(context.Context, *ObjectPointCloudsRequest) (*ObjectPointCloudsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObjectPointClouds not implemented")
}
func (UnimplementedRobotServiceServer) LidarInfo(context.Context, *LidarInfoRequest) (*LidarInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarInfo not implemented")
}
func (UnimplementedRobotServiceServer) LidarStart(context.Context, *LidarStartRequest) (*LidarStartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarStart not implemented")
}
func (UnimplementedRobotServiceServer) LidarStop(context.Context, *LidarStopRequest) (*LidarStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarStop not implemented")
}
func (UnimplementedRobotServiceServer) LidarScan(context.Context, *LidarScanRequest) (*LidarScanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarScan not implemented")
}
func (UnimplementedRobotServiceServer) LidarRange(context.Context, *LidarRangeRequest) (*LidarRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarRange not implemented")
}
func (UnimplementedRobotServiceServer) LidarBounds(context.Context, *LidarBoundsRequest) (*LidarBoundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarBounds not implemented")
}
func (UnimplementedRobotServiceServer) LidarAngularResolution(context.Context, *LidarAngularResolutionRequest) (*LidarAngularResolutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarAngularResolution not implemented")
}
func (UnimplementedRobotServiceServer) BoardStatus(context.Context, *BoardStatusRequest) (*BoardStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardStatus not implemented")
}
func (UnimplementedRobotServiceServer) BoardGPIOSet(context.Context, *BoardGPIOSetRequest) (*BoardGPIOSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardGPIOSet not implemented")
}
func (UnimplementedRobotServiceServer) BoardGPIOGet(context.Context, *BoardGPIOGetRequest) (*BoardGPIOGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardGPIOGet not implemented")
}
func (UnimplementedRobotServiceServer) BoardPWMSet(context.Context, *BoardPWMSetRequest) (*BoardPWMSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardPWMSet not implemented")
}
func (UnimplementedRobotServiceServer) BoardPWMSetFrequency(context.Context, *BoardPWMSetFrequencyRequest) (*BoardPWMSetFrequencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardPWMSetFrequency not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorPower(context.Context, *BoardMotorPowerRequest) (*BoardMotorPowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorPower not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorGo(context.Context, *BoardMotorGoRequest) (*BoardMotorGoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorGo not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorGoFor(context.Context, *BoardMotorGoForRequest) (*BoardMotorGoForResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorGoFor not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorGoTo(context.Context, *BoardMotorGoToRequest) (*BoardMotorGoToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorGoTo not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorGoTillStop(context.Context, *BoardMotorGoTillStopRequest) (*BoardMotorGoTillStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorGoTillStop not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorZero(context.Context, *BoardMotorZeroRequest) (*BoardMotorZeroResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorZero not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorPosition(context.Context, *BoardMotorPositionRequest) (*BoardMotorPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorPosition not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorPositionSupported(context.Context, *BoardMotorPositionSupportedRequest) (*BoardMotorPositionSupportedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorPositionSupported not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorOff(context.Context, *BoardMotorOffRequest) (*BoardMotorOffResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorOff not implemented")
}
func (UnimplementedRobotServiceServer) BoardMotorIsOn(context.Context, *BoardMotorIsOnRequest) (*BoardMotorIsOnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardMotorIsOn not implemented")
}
func (UnimplementedRobotServiceServer) BoardServoMove(context.Context, *BoardServoMoveRequest) (*BoardServoMoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardServoMove not implemented")
}
func (UnimplementedRobotServiceServer) BoardServoCurrent(context.Context, *BoardServoCurrentRequest) (*BoardServoCurrentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardServoCurrent not implemented")
}
func (UnimplementedRobotServiceServer) BoardAnalogReaderRead(context.Context, *BoardAnalogReaderReadRequest) (*BoardAnalogReaderReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardAnalogReaderRead not implemented")
}
func (UnimplementedRobotServiceServer) BoardDigitalInterruptConfig(context.Context, *BoardDigitalInterruptConfigRequest) (*BoardDigitalInterruptConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardDigitalInterruptConfig not implemented")
}
func (UnimplementedRobotServiceServer) BoardDigitalInterruptValue(context.Context, *BoardDigitalInterruptValueRequest) (*BoardDigitalInterruptValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardDigitalInterruptValue not implemented")
}
func (UnimplementedRobotServiceServer) BoardDigitalInterruptTick(context.Context, *BoardDigitalInterruptTickRequest) (*BoardDigitalInterruptTickResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardDigitalInterruptTick not implemented")
}
func (UnimplementedRobotServiceServer) SensorReadings(context.Context, *SensorReadingsRequest) (*SensorReadingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SensorReadings not implemented")
}
func (UnimplementedRobotServiceServer) CompassHeading(context.Context, *CompassHeadingRequest) (*CompassHeadingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassHeading not implemented")
}
func (UnimplementedRobotServiceServer) CompassStartCalibration(context.Context, *CompassStartCalibrationRequest) (*CompassStartCalibrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassStartCalibration not implemented")
}
func (UnimplementedRobotServiceServer) CompassStopCalibration(context.Context, *CompassStopCalibrationRequest) (*CompassStopCalibrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassStopCalibration not implemented")
}
func (UnimplementedRobotServiceServer) CompassMark(context.Context, *CompassMarkRequest) (*CompassMarkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassMark not implemented")
}
func (UnimplementedRobotServiceServer) mustEmbedUnimplementedRobotServiceServer() {}

// UnsafeRobotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RobotServiceServer will
// result in compilation errors.
type UnsafeRobotServiceServer interface {
	mustEmbedUnimplementedRobotServiceServer()
}

func RegisterRobotServiceServer(s grpc.ServiceRegistrar, srv RobotServiceServer) {
	s.RegisterService(&RobotService_ServiceDesc, srv)
}

func _RobotService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_StatusStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatusStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotServiceServer).StatusStream(m, &robotServiceStatusStreamServer{stream})
}

type RobotService_StatusStreamServer interface {
	Send(*StatusStreamResponse) error
	grpc.ServerStream
}

type robotServiceStatusStreamServer struct {
	grpc.ServerStream
}

func (x *robotServiceStatusStreamServer) Send(m *StatusStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RobotService_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/Config",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).Config(ctx, req.(*ConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_DoAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).DoAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/DoAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).DoAction(ctx, req.(*DoActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ArmCurrentPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmCurrentPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ArmCurrentPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ArmCurrentPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ArmCurrentPosition(ctx, req.(*ArmCurrentPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ArmMoveToPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmMoveToPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ArmMoveToPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ArmMoveToPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ArmMoveToPosition(ctx, req.(*ArmMoveToPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ArmCurrentJointPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmCurrentJointPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ArmCurrentJointPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ArmCurrentJointPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ArmCurrentJointPositions(ctx, req.(*ArmCurrentJointPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ArmMoveToJointPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmMoveToJointPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ArmMoveToJointPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ArmMoveToJointPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ArmMoveToJointPositions(ctx, req.(*ArmMoveToJointPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ArmJointMoveDelta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmJointMoveDeltaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ArmJointMoveDelta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ArmJointMoveDelta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ArmJointMoveDelta(ctx, req.(*ArmJointMoveDeltaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseMoveStraight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseMoveStraightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseMoveStraight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseMoveStraight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseMoveStraight(ctx, req.(*BaseMoveStraightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseSpin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseSpinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseSpin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseSpin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseSpin(ctx, req.(*BaseSpinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseStop(ctx, req.(*BaseStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseWidthMillis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseWidthMillisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseWidthMillis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseWidthMillis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseWidthMillis(ctx, req.(*BaseWidthMillisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_GripperOpen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GripperOpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).GripperOpen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/GripperOpen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).GripperOpen(ctx, req.(*GripperOpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_GripperGrab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GripperGrabRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).GripperGrab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/GripperGrab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).GripperGrab(ctx, req.(*GripperGrabRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CameraFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CameraFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CameraFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CameraFrame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CameraFrame(ctx, req.(*CameraFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CameraRenderFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CameraRenderFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CameraRenderFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CameraRenderFrame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CameraRenderFrame(ctx, req.(*CameraRenderFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_PointCloud_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointCloudRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).PointCloud(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/PointCloud",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).PointCloud(ctx, req.(*PointCloudRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ObjectPointClouds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectPointCloudsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ObjectPointClouds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ObjectPointClouds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ObjectPointClouds(ctx, req.(*ObjectPointCloudsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarInfo(ctx, req.(*LidarInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarStart(ctx, req.(*LidarStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarStop(ctx, req.(*LidarStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarScan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarScan(ctx, req.(*LidarScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarRange(ctx, req.(*LidarRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarBounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarBoundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarBounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarBounds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarBounds(ctx, req.(*LidarBoundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarAngularResolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarAngularResolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarAngularResolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarAngularResolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarAngularResolution(ctx, req.(*LidarAngularResolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardStatus(ctx, req.(*BoardStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardGPIOSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardGPIOSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardGPIOSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardGPIOSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardGPIOSet(ctx, req.(*BoardGPIOSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardGPIOGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardGPIOGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardGPIOGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardGPIOGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardGPIOGet(ctx, req.(*BoardGPIOGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardPWMSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardPWMSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardPWMSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardPWMSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardPWMSet(ctx, req.(*BoardPWMSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardPWMSetFrequency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardPWMSetFrequencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardPWMSetFrequency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardPWMSetFrequency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardPWMSetFrequency(ctx, req.(*BoardPWMSetFrequencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorPower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorPowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorPower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorPower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorPower(ctx, req.(*BoardMotorPowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorGo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorGoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorGo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorGo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorGo(ctx, req.(*BoardMotorGoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorGoFor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorGoForRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorGoFor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorGoFor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorGoFor(ctx, req.(*BoardMotorGoForRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorGoTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorGoToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorGoTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorGoTo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorGoTo(ctx, req.(*BoardMotorGoToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorGoTillStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorGoTillStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorGoTillStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorGoTillStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorGoTillStop(ctx, req.(*BoardMotorGoTillStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorZero_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorZeroRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorZero(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorZero",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorZero(ctx, req.(*BoardMotorZeroRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorPosition(ctx, req.(*BoardMotorPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorPositionSupported_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorPositionSupportedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorPositionSupported(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorPositionSupported",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorPositionSupported(ctx, req.(*BoardMotorPositionSupportedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorOffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorOff",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorOff(ctx, req.(*BoardMotorOffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardMotorIsOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardMotorIsOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardMotorIsOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardMotorIsOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardMotorIsOn(ctx, req.(*BoardMotorIsOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardServoMove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardServoMoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardServoMove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardServoMove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardServoMove(ctx, req.(*BoardServoMoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardServoCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardServoCurrentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardServoCurrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardServoCurrent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardServoCurrent(ctx, req.(*BoardServoCurrentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardAnalogReaderRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardAnalogReaderReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardAnalogReaderRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardAnalogReaderRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardAnalogReaderRead(ctx, req.(*BoardAnalogReaderReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardDigitalInterruptConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardDigitalInterruptConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardDigitalInterruptConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardDigitalInterruptConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardDigitalInterruptConfig(ctx, req.(*BoardDigitalInterruptConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardDigitalInterruptValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardDigitalInterruptValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardDigitalInterruptValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardDigitalInterruptValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardDigitalInterruptValue(ctx, req.(*BoardDigitalInterruptValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardDigitalInterruptTick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardDigitalInterruptTickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardDigitalInterruptTick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardDigitalInterruptTick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardDigitalInterruptTick(ctx, req.(*BoardDigitalInterruptTickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_SensorReadings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorReadingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).SensorReadings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/SensorReadings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).SensorReadings(ctx, req.(*SensorReadingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassHeading_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassHeadingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassHeading(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassHeading",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassHeading(ctx, req.(*CompassHeadingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassStartCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassStartCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassStartCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassStartCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassStartCalibration(ctx, req.(*CompassStartCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassStopCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassStopCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassStopCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassStopCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassStopCalibration(ctx, req.(*CompassStopCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassMark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassMarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassMark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassMark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassMark(ctx, req.(*CompassMarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RobotService_ServiceDesc is the grpc.ServiceDesc for RobotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RobotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.v1.RobotService",
	HandlerType: (*RobotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _RobotService_Status_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _RobotService_Config_Handler,
		},
		{
			MethodName: "DoAction",
			Handler:    _RobotService_DoAction_Handler,
		},
		{
			MethodName: "ArmCurrentPosition",
			Handler:    _RobotService_ArmCurrentPosition_Handler,
		},
		{
			MethodName: "ArmMoveToPosition",
			Handler:    _RobotService_ArmMoveToPosition_Handler,
		},
		{
			MethodName: "ArmCurrentJointPositions",
			Handler:    _RobotService_ArmCurrentJointPositions_Handler,
		},
		{
			MethodName: "ArmMoveToJointPositions",
			Handler:    _RobotService_ArmMoveToJointPositions_Handler,
		},
		{
			MethodName: "ArmJointMoveDelta",
			Handler:    _RobotService_ArmJointMoveDelta_Handler,
		},
		{
			MethodName: "BaseMoveStraight",
			Handler:    _RobotService_BaseMoveStraight_Handler,
		},
		{
			MethodName: "BaseSpin",
			Handler:    _RobotService_BaseSpin_Handler,
		},
		{
			MethodName: "BaseStop",
			Handler:    _RobotService_BaseStop_Handler,
		},
		{
			MethodName: "BaseWidthMillis",
			Handler:    _RobotService_BaseWidthMillis_Handler,
		},
		{
			MethodName: "GripperOpen",
			Handler:    _RobotService_GripperOpen_Handler,
		},
		{
			MethodName: "GripperGrab",
			Handler:    _RobotService_GripperGrab_Handler,
		},
		{
			MethodName: "CameraFrame",
			Handler:    _RobotService_CameraFrame_Handler,
		},
		{
			MethodName: "CameraRenderFrame",
			Handler:    _RobotService_CameraRenderFrame_Handler,
		},
		{
			MethodName: "PointCloud",
			Handler:    _RobotService_PointCloud_Handler,
		},
		{
			MethodName: "ObjectPointClouds",
			Handler:    _RobotService_ObjectPointClouds_Handler,
		},
		{
			MethodName: "LidarInfo",
			Handler:    _RobotService_LidarInfo_Handler,
		},
		{
			MethodName: "LidarStart",
			Handler:    _RobotService_LidarStart_Handler,
		},
		{
			MethodName: "LidarStop",
			Handler:    _RobotService_LidarStop_Handler,
		},
		{
			MethodName: "LidarScan",
			Handler:    _RobotService_LidarScan_Handler,
		},
		{
			MethodName: "LidarRange",
			Handler:    _RobotService_LidarRange_Handler,
		},
		{
			MethodName: "LidarBounds",
			Handler:    _RobotService_LidarBounds_Handler,
		},
		{
			MethodName: "LidarAngularResolution",
			Handler:    _RobotService_LidarAngularResolution_Handler,
		},
		{
			MethodName: "BoardStatus",
			Handler:    _RobotService_BoardStatus_Handler,
		},
		{
			MethodName: "BoardGPIOSet",
			Handler:    _RobotService_BoardGPIOSet_Handler,
		},
		{
			MethodName: "BoardGPIOGet",
			Handler:    _RobotService_BoardGPIOGet_Handler,
		},
		{
			MethodName: "BoardPWMSet",
			Handler:    _RobotService_BoardPWMSet_Handler,
		},
		{
			MethodName: "BoardPWMSetFrequency",
			Handler:    _RobotService_BoardPWMSetFrequency_Handler,
		},
		{
			MethodName: "BoardMotorPower",
			Handler:    _RobotService_BoardMotorPower_Handler,
		},
		{
			MethodName: "BoardMotorGo",
			Handler:    _RobotService_BoardMotorGo_Handler,
		},
		{
			MethodName: "BoardMotorGoFor",
			Handler:    _RobotService_BoardMotorGoFor_Handler,
		},
		{
			MethodName: "BoardMotorGoTo",
			Handler:    _RobotService_BoardMotorGoTo_Handler,
		},
		{
			MethodName: "BoardMotorGoTillStop",
			Handler:    _RobotService_BoardMotorGoTillStop_Handler,
		},
		{
			MethodName: "BoardMotorZero",
			Handler:    _RobotService_BoardMotorZero_Handler,
		},
		{
			MethodName: "BoardMotorPosition",
			Handler:    _RobotService_BoardMotorPosition_Handler,
		},
		{
			MethodName: "BoardMotorPositionSupported",
			Handler:    _RobotService_BoardMotorPositionSupported_Handler,
		},
		{
			MethodName: "BoardMotorOff",
			Handler:    _RobotService_BoardMotorOff_Handler,
		},
		{
			MethodName: "BoardMotorIsOn",
			Handler:    _RobotService_BoardMotorIsOn_Handler,
		},
		{
			MethodName: "BoardServoMove",
			Handler:    _RobotService_BoardServoMove_Handler,
		},
		{
			MethodName: "BoardServoCurrent",
			Handler:    _RobotService_BoardServoCurrent_Handler,
		},
		{
			MethodName: "BoardAnalogReaderRead",
			Handler:    _RobotService_BoardAnalogReaderRead_Handler,
		},
		{
			MethodName: "BoardDigitalInterruptConfig",
			Handler:    _RobotService_BoardDigitalInterruptConfig_Handler,
		},
		{
			MethodName: "BoardDigitalInterruptValue",
			Handler:    _RobotService_BoardDigitalInterruptValue_Handler,
		},
		{
			MethodName: "BoardDigitalInterruptTick",
			Handler:    _RobotService_BoardDigitalInterruptTick_Handler,
		},
		{
			MethodName: "SensorReadings",
			Handler:    _RobotService_SensorReadings_Handler,
		},
		{
			MethodName: "CompassHeading",
			Handler:    _RobotService_CompassHeading_Handler,
		},
		{
			MethodName: "CompassStartCalibration",
			Handler:    _RobotService_CompassStartCalibration_Handler,
		},
		{
			MethodName: "CompassStopCalibration",
			Handler:    _RobotService_CompassStopCalibration_Handler,
		},
		{
			MethodName: "CompassMark",
			Handler:    _RobotService_CompassMark_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StatusStream",
			Handler:       _RobotService_StatusStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/api/v1/robot.proto",
}
